package CQRS.typesystem;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import java.util.ArrayList;
import org.jetbrains.mps.openapi.language.SProperty;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;

public class INamedConceptExtensions {
  public INamedConceptExtensions() {
  }
  public static void forEachDuplicateName(final Iterable<SNode> _this, _FunctionTypes._void_P1_E0<? super SNode> callback) {
    if (Sequence.fromIterable(_this).count() < 2) {
      return;
    }

    Map<String, Integer> nameIndexMap = MapSequence.fromMap(new HashMap<String, Integer>());
    List<SNode> nodes = Sequence.fromIterable(_this).toListSequence();

    for (int i = 0; i < Sequence.fromIterable(_this).count(); i++) {
      SNode node = ListSequence.fromList(nodes).getElement(i);

      if (SPropertyOperations.getString(node, PROPS.name$MnvL) == null) {
        continue;
      }

      if (!(MapSequence.fromMap(nameIndexMap).containsKey(SPropertyOperations.getString(node, PROPS.name$MnvL)))) {
        MapSequence.fromMap(nameIndexMap).put(SPropertyOperations.getString(node, PROPS.name$MnvL), i);
      } else {
        callback.invoke(node);
        callback.invoke(ListSequence.fromList(nodes).getElement(MapSequence.fromMap(nameIndexMap).get(SPropertyOperations.getString(node, PROPS.name$MnvL))));
      }
    }
  }
  public static void forEachNodeWhichStartsWithLowercase(final Iterable<SNode> _this, _FunctionTypes._void_P1_E0<? super SNode> callback) {
    Sequence.fromIterable(_this).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return !(INamedConceptExtensions.startsWithUppercaseLetter(it));
      }
    }).visitAll(callback);
  }
  public static boolean startsWithUppercaseLetter(final SNode _this) {
    return (SPropertyOperations.getString(_this, PROPS.name$MnvL) == null ? false : (Character.isLetter(SPropertyOperations.getString(_this, PROPS.name$MnvL).charAt(0)) && Character.isUpperCase(SPropertyOperations.getString(_this, PROPS.name$MnvL).charAt(0))));
  }
  public static boolean startsWithLowercaseLetter(final SNode _this) {
    return (SPropertyOperations.getString(_this, PROPS.name$MnvL) == null ? false : (Character.isLetter(SPropertyOperations.getString(_this, PROPS.name$MnvL).charAt(0)) && Character.isLowerCase(SPropertyOperations.getString(_this, PROPS.name$MnvL).charAt(0))));
  }
  public static void forEachDuplicateNameOld(final Iterable<SNode> _this, final _FunctionTypes._void_P1_E0<? super SNode> callback) {
    final Set<String> duplicateNameList = SetSequence.fromSet(new HashSet<String>());

    Sequence.fromIterable(_this).visitAll(new IVisitor<SNode>() {
      public void visit(SNode it) {
        if (!(SetSequence.fromSet(duplicateNameList).contains(SPropertyOperations.getString(it, PROPS.name$MnvL)))) {
          SetSequence.fromSet(duplicateNameList).addElement(SPropertyOperations.getString(it, PROPS.name$MnvL));
        } else if (SPropertyOperations.getString(it, PROPS.name$MnvL) != null) {
          callback.invoke(it);
        }
      }
    });
  }
  public static Iterable<List<SNode>> findNodesWithSameName(final Iterable<SNode> _this) {
    final Map<String, List<SNode>> conceptMap = MapSequence.fromMap(new HashMap<String, List<SNode>>());

    Sequence.fromIterable(_this).visitAll(new IVisitor<SNode>() {
      public void visit(SNode it) {
        if (!(MapSequence.fromMap(conceptMap).containsKey(SPropertyOperations.getString(it, PROPS.name$MnvL))) && SPropertyOperations.getString(it, PROPS.name$MnvL) != null) {
          List<SNode> list = ListSequence.fromList(new ArrayList<SNode>());
          ListSequence.fromList(list).addElement(it);
          MapSequence.fromMap(conceptMap).put(SPropertyOperations.getString(it, PROPS.name$MnvL), list);
        } else if (SPropertyOperations.getString(it, PROPS.name$MnvL) != null) {
          ListSequence.fromList(MapSequence.fromMap(conceptMap).get(SPropertyOperations.getString(it, PROPS.name$MnvL))).addElement(it);
        }
      }
    });

    return Sequence.fromIterable(MapSequence.fromMap(conceptMap).values()).where(new IWhereFilter<List<SNode>>() {
      public boolean accept(List<SNode> it) {
        return ListSequence.fromList(it).count() > 1;
      }
    });
  }

  private static final class PROPS {
    /*package*/ static final SProperty name$MnvL = MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name");
  }
}
